<html>
<head>
<title>Ultimate Meme Manager</title>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, viewport-fit=cover"/>
<link rel="stylesheet" href="style.css"/>
<link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
<style>
  @font-face {
    font-family: 'Roboto';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: local('Roboto'), local('Roboto-Regular'), url('https://fonts.gstatic.com/s/roboto/v20/KFOmCnqEu92Fr1Mu4mxK.woff2') format('woff2');
  }

  @font-face {
    font-family: 'League Gothic';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: local('League Gothic'), local('League Gothic'), url('/league-gothic-regular.otf') format('otf');
  }

  [v-cloak] {
    display: none !important
  }

  #img {
    display: block;
    visibility: hidden;
    width: 100%;
  }
  .container {
    align-items: center;
    display: flex;
    justify-content: center;
    overflow: hidden;
    position: relative;
  }

  .container.container--might-drag {
    cursor: move; /* fallback if grab cursor is unsupported */
    cursor: grab;
    cursor: -moz-grab;
    cursor: -webkit-grab;
  }

  .container.container--might-drag.container--dragging {
    cursor: grabbing;
    cursor: -moz-grabbing;
    cursor: -webkit-grabbing;
  }

  #container div {
    background: transparent;
    box-sizing: border-box;
    border: 1px dashed #666;
    position: absolute;
    left: 0;
    margin: 0 auto;
    top: 0;
  }

  #container input:focus {
    outline: none;
  }

  .meme-text-input {
    border-radius: 5px;
    margin: 10px 0 0;
  }
</style>
</head>
<body>
<div id="app">
  <div class="webapp-cont">
    <a
      href="./"
      style="display: block;margin-top: 10px;"
    >Back</a>
    <h1>Ultimate Meme Manager</h1>
    <h2>Add text</h2>
    <div
      id="container"
      class="container"
      :class="{
        'container--might-drag': vdMightDrag,
        'container--dragging': vdDragging,
      }"
      style="margin-top: 8px;"
    >
      <img id="img"/>
    </div>
    <input
      v-for="r in vdBoxes.length"
      :key="r"
      :placeholder="'Text ' + r"
      class="meme-text-input"
      type="text"
      v-model="vdTexts[r]"
    />
    <div style="display: flex;width: 100%;padding: 8px 0 5px;">
      <button
        class="btn"
        @click="mtdAddText"
        style="margin: auto 0 auto auto;"
      >Add text</button>
    </div>
    <button
      class="btn"
      id="download-button"
      style="margin: 10px auto;"
    >Download</button>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/p5@1.0.0/lib/p5.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js"></script>
<script>
// alternative feImagePath = '$ { tplImagePath }';

/**
 * To read GET variables php style (kinda). Remember that this is a function, so it's not used $_GET[] but $_GET().
 *
 * @param {string} parameterName - The GET variable you're considering. E.g. if the url is sending ?q=1 you'll use $_GET('q').
 * @return {string|null} The value in that variable or null.
 */
var $_GET = function(parameterName) {
  /* global location*/
  var result = null;
  location.search
    .substr(1)
    .split('&')
    .forEach(function(foundGetVar) {
      var tmp = foundGetVar.split('=');
      if (tmp[0] === parameterName) result = decodeURIComponent(tmp[1]);
    });
  return result;
};

let imgWidth = 0;
let imgHeight = 0;

new Vue({
  el: '#app',
  data: function() { // eslint-disable-line require-jsdoc
    return {
      vdBoxes: [],
      vdTexts: [null, ''],
      vdBoxModel: {
        dragging: false,
        left: 0,
        top: 0,
        width: 0,
        height: 80,
        draggingOffsetX: 0,
        draggingOffsetY: 0,
      },
      vdMightDrag: false,
      vdDragging: false,
    };
  },
  mounted: function() {
    let feImagePath = 'memes/' + $_GET('i');

    let vueInstanceData = this._data;
    let img = document.getElementById('img');
    img.onload = function() {
      imgWidth = this.width;
      imgHeight = this.height;
      this.style.display = 'none';

      new p5(function(p) {
        let font1;
        let bg;

        vueInstanceData.vdBoxes.push(JSON.parse(JSON.stringify(vueInstanceData.vdBoxModel)));
        p.preload = function() {
          font1 = p.loadFont('anton-regular.ttf');
          bg = p.loadImage(feImagePath);
        }
        let textBox = document.getElementById('textbox');
        p.setup = function() {
          p.createCanvas(imgWidth, imgHeight, p.WEBGL);

          p.translate(imgWidth / 2 * -1, imgHeight / 2 * -1);

          p.textFont(font1);

          vueInstanceData.vdBoxes.forEach(function(eachBox) {
            eachBox.width = Math.floor(imgWidth * .8);
            eachBox.left = Math.floor((imgWidth - Math.floor(imgWidth * .8)) / 2);
          });
        }
        p.mousePressed = function() {
          let foundOne = false;
          for (let r = vueInstanceData.vdBoxes.length - 1; r >= 0; r--) {
            const eachBox = vueInstanceData.vdBoxes[r];
            if (foundOne) return;
            if (
              p.mouseX > eachBox.left &&
              p.mouseX < eachBox.left + eachBox.width &&
              p.mouseY > eachBox.top &&
              p.mouseY < eachBox.top + eachBox.height
            ) {
              foundOne = true;
              eachBox.dragging = true;
              eachBox.draggingOffsetX = p.mouseX - eachBox.left;
              eachBox.draggingOffsetY = p.mouseY - eachBox.top;
              vueInstanceData.vdDragging = true;
            }
          }
        }
        p.mouseReleased = function() {
          vueInstanceData.vdBoxes.forEach(function(eachBox) {
            eachBox.dragging = false;
          });
          vueInstanceData.vdDragging = false;
        }

        p.draw = function() {
          p.translate(imgWidth / 2 * -1, imgHeight / 2 * -1);
          p.image(bg, 0, 0, imgWidth, imgHeight);

          p.strokeWeight(1)
          p.stroke(255)
          p.fill(255, 255, 255, 0)

          let mightDrag = false;
          vueInstanceData.vdBoxes.forEach(function(eachBox) {
            if (eachBox.dragging) {
              var leftPos = (p.mouseX - eachBox.draggingOffsetX);
              if (leftPos < 0) leftPos = 0;
              if (leftPos > imgWidth - eachBox.width) leftPos = imgWidth - eachBox.width;
              eachBox.left = leftPos;
              var topPos = (p.mouseY - eachBox.draggingOffsetY);
              if (topPos < 0) topPos = 0;
              if (topPos > imgHeight - eachBox.height) topPos = imgHeight - eachBox.height;
              eachBox.top = topPos;
            }

            mightDrag = (
              p.mouseX > eachBox.left &&
              p.mouseX < eachBox.left + eachBox.width &&
              p.mouseY > eachBox.top &&
              p.mouseY < eachBox.top + eachBox.height
            )

            if (
              p.mouseX > 0 && p.mouseX < imgWidth &&
              p.mouseY > 0 && p.mouseY < imgHeight
            )
              p.rect(eachBox.left, eachBox.top, eachBox.width, eachBox.height);
          });
          vueInstanceData.vdMightDrag = mightDrag;

          // p.filter(p.BLUR);
          p.textAlign(p.CENTER);
          p.textSize(42);

          let topOffset = 11;
          let leftOffset = 4;
          let positions = [1, 2, 2.5];

          vueInstanceData.vdBoxes.forEach(function(eachBox, i) {
            p.fill(0, 0, 0);

            positions.forEach(function(eachPos) {
              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset - eachPos, eachBox.top + topOffset - eachPos, eachBox.width, eachBox.height);
              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset, eachBox.top + topOffset - eachPos, eachBox.width, eachBox.height);
              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset + eachPos, eachBox.top + topOffset - eachPos, eachBox.width, eachBox.height);

              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset - eachPos, eachBox.top + topOffset, eachBox.width, eachBox.height);
              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset + eachPos, eachBox.top + topOffset, eachBox.width, eachBox.height);

              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset - eachPos, eachBox.top + topOffset + eachPos, eachBox.width, eachBox.height);
              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset, eachBox.top + topOffset + eachPos, eachBox.width, eachBox.height);
              p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset + eachPos, eachBox.top + topOffset + eachPos, eachBox.width, eachBox.height);
            });

            p.fill(255, 255, 255);
            p.text(vueInstanceData.vdTexts[i + 1].toUpperCase(), eachBox.left + leftOffset, eachBox.top + topOffset, eachBox.width, eachBox.height);
          });
        }

        document.getElementById('download-button').onclick = function() {
          var filePart = feImagePath.split('/');
          p.saveCanvas(filePart[filePart.length - 1]);
        };
      }, 'container');
    }
    img.src = feImagePath;
  },
  methods: {
    /**
     *
     */
    mtdAddText: function() {
      this.vdBoxes.push(JSON.parse(JSON.stringify(this.vdBoxModel)));
      this.vdBoxes[this.vdBoxes.length - 1].width = Math.floor(imgWidth * .8);
      this.vdBoxes[this.vdBoxes.length - 1].left = Math.floor((imgWidth - Math.floor(imgWidth * .8)) / 2);
      this.vdTexts.push('');
    },
  }
});
</script>
</body>
</html>
